A high-level type system for the Free Desktops
==============================================

Desktop environments are not just for starting applications anymore.
Data is flowing freely between well-integrated components, and the
easier the data flows, the better the integration of the components.

Not all components are written in the same programming language, of
course, and when letting data flow between them, it needs to be
represented in many different ways.  For example, GConf stores values
differently than they travel over D-Bus, which is different again from
how they are passed as GValues to signal handlers, which is different
from how Perl wants to store it.

The desktop environment is heading towards a cooperative, dynamic
environment, and it needs a rich and strong type system to tie its
components together.  Sending lines of text over pipes and matching
them against ad-hoc regular expressions just doesn't cut it.

In an attempt to define such a common type system, this document
collects many different systems for representing values, and unifies
them by mapping the common dynamic type system into them.

The common type system defined here is rich enough to represent any
reasonable value; it's roughly equivalent to what dynamic languages
like Perl and Python have.

But it goes one crucial step further: it allows the definition of new
abstract, intentional types.  Intentional types give additional
information about a value that is not available from the
representation alone.

For example, a integer can be used to denote a point in time by saying
that it is the number of seconds since a certain epoch.  All places
that interact with such a value need to agree on this intention.

This agreement can happen informally, via documentation or just plain
common sense.  Nothing wrong with that.  It is, however, also helpful
to formalize this so that documentation can be precise without much
extra effort, up to a level where the machine itself is able to check
whether everybody agrees on the intentional types.

The age old battle between static and dynamic types also matters here:
how much type information should be associated with the values
themselves?  The boundary is exactly between intentional and
representational types.  Intentional types are those that only the
programmer or compiler know about, representational types are those
that are only known at run-time.

In a completely statically typed language, we only have raw bytes at
run-time without any representational type information.  All parts of
the program need to agree that the intention is for those four bytes
over there to be used as a 32-bit integer.  Statically typed programs
are littered with declarations of intentional types, and language
processors use them to (more or less) check program consistency and to
select the right division instruction based on whether the four bytes
over there are intended to be a signed number or an unsigned one.

In a dynamically typed language, values carry a lot of
representational type information.  Code can easily be polymorphic and
do different things depending on whether a value is an integer or a
string.  It can also perform consistency checks at run-time, which is
more robust than doing it at compile time, but doesn't go as far since
intentional types are not available.

Dynamic languages often don't have any means to declare intentional
types for the benefit of the compiler; they only exist in the head of
the programmer who expresses them by selecting the right operation
manually.  For example, if a string is intended to be a URL, you need
to use 'utils.net.web.url.get_scheme (url)' explicitly.  If the
intentional type could have been declared in the language, it could
have selected the right function automatically from just 'url.scheme()'.

Thus, and coming back to the ground now, we define a concrete type
system here with a rich representational part and a lightweight and
flexible intentional part.

For the representational part, we define how it is implemented for a
number of existing value systems.  For the intentional part, we define
how it can be translated into a number of languages, both those with
static type declaration and those where intent is mainly expressed by
manually selecting the right operations.

Intentional types are not optional; they are generally needed to make
sense of values.  A programmer learns about them by reading
documentation; if a debugging tool needs to find out a intentional
type at run-time, there must be some way to find it.

This means that declaration languages like D-Bus introspection
facilities and GConf schemas need to be extended to support our
intentional types.  Thus, purely declarative languages like these are
also included in our list of supported languages.

[ Insert example here. ]

We also give a list of common intentional types, of course.

This document then has three dimensions of extensibility:

- A new value system can be added by defining how the representational
  part of the common type system maps to it.

- A new language can be added by defining how intentional types are
  implemented in it, and by implementing all common intentional types.

- A new common intentional type can be added by defining it and
  implementing it in all languages.

The representational part of the common type system is not supposed to
change frequently, but adding a new intentional type should be
considered routine.

The representation part of the common type system is restricted by the
lowest common denominator of all the value system implementations that
we want to include.  We don't want to distort the existing value
systems too much, and force people to write code that feels unnatural
for them.

For example, not all value systems can directly represent complex
numbers or multiple precision integers, but any grown up type system
should include them.  We solve this conflict by relying on the
intentional types: Instead of grafting complex numbers onto every
value system, we only define a intentional type for them.

Currently supported value systems: QVariant, D-Bus messages, GValue,
GConfValue, GVariant, Python values, Perl values, JavaScript values,
GKeyFile, JSON, YAML, Nepomuk ontologies, SQL, SparQL.

Currently supported languages: Python, Perl, JavaScript, Java, C#, C++
with QVariant, C with D-Bus/GValue/GConfValue/GVariant, Vala, D-Bus
introspection, D-Bus IDL (didl), GConf schema, our own XML schema.


Representational types
----------------------

Whenever there is a choice of representation in the following table,
it should be taken to mean: Represent the value with the first
alternative in the list that is possible, even if that loses
precision.

For example, a 64 bit signed integer is represented in GConf as a
"int" if it fits, and as a "double" if not.  It will always fit into a
double, but it might mean chopping off some low bits.

The XML value system is a new invention of this document.  It will
eventually get its own schema and namespace, of course.

- null

  The null value.

  [ Not sure about this at all.  Need to review existing D-Bus
    bindings to Perl etc.]

  QVariant:   QVariant::Null
  D-Bus:      '()'
  GValue:     G_TYPE_NONE
  GConf:      empty GCONF_VALUE_LIST with type GCONF_VALUE_BOOL
  GVariant:   '()'
  Perl:       undef
  Python 2:   None
  XML:        <null/>

- bool

  A boolean

  QVariant:   QVariant::Bool
  D-Bus:      'b'
  GValue:     G_TYPE_BOOLEAN
  GConf:      GCONF_VALUE_BOOL
  GVariant:   'b'
  Perl:       number, 0 or 1.
  Python 2:   number, 0 or 1.
  XML:        <true/>  or  <false/>

- int32

  Signed 32 bit integer

  QVariant:   QVariant::Int
  D-Bus:      'i'
  GValue:     G_TYPE_INT
  GConf:      GCONF_VALUE_INT
  GVariant:   'i'
  Perl:       number
  Python 2:   int
  XML:        <i v="12345">

- int64

  Signed 64 bit integer

  QVariant:   QVariant::LongLong
  D-Bus:      'x'
  GValue:     G_TYPE_INT64
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   'x'
  Perl:       number
  Python 2:   int or long
  XML:        <x v="12345">

- uint32

  Unsigned 32 bit integer

  QVariant:   QVariant::UInt
  D-Bus:      'u'
  GValue:     G_TYPE_UINT
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   'u'
  Perl:       number
  Python 2:   int or long
  XML:        <u v="12345">

- uint64

  Unsigned 64 bit integer

  QVariant:   QVariant::ULongLong
  D-Bus:      't'
  GValue:     G_TYPE_UINT64
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   't'
  Perl:       number
  Python 2:   int or long
  XML:        <t v="12345">

- double

  Double precision floating point number

  QVariant:   QVariant::Double
  D-Bus:      'd'
  GValue:     G_TYPE_DOUBLE 
  GConf:      GCONF_VALUE_DOUBLE
  GVariant:   'd'
  Perl:       number
  Python 2:   double
  XML:        <d v="12345.67">

- string

  String of Unicode code points

  QVariant:   QVariant::QString
  D-Bus:      's'
  GValue:     G_TYPE_STRING
  GConf:      GCONF_VALUE_STRING, UTF-8.
  GVariant:   's'
  Perl:       string
  Python 2:   unicode
  XML:        <s v="abcde">

- sequence

  Sequence of values

  QVariant:   QVariant::List
  D-Bus:      'av'
  GValue:     G_TYPE_POINTER pointing to a GSList of GValues.
              (XXX - find something better, must be somewhere.)
  GConf:      GCONF_VALUE_LIST or chained GCONF_VALUE_PAIRs
  GVariant:   'av'
  Perl:       array
  Python 2:   list
  XML:        <a>VAL...</a>

- map

  Mapping from strings to values, with no duplicated keys.

  QVariant:   QVariant::Map
  D-Bus:      'a{sv}'
  GValue:     G_TYPE_HASH_TABLE (?)
  GConf:      Chain of GCONF_VALUE_PAIRs,
              with the cars being a pair of GCONF_VALUE_STRING and an
              arbitrary value.
  GVariant:   'a{sv}'
  Perl:       hash
  Python:     dict
  XML:        <m>ENTRY...</m>  where ENTRY is <e k="abcde">VAL</e>


Intentional types
-----------------

The most important part of a intentional type definition is its
documentation.  The documentation is the thing that explains the
intent to programmers, so that they can 'reify' the abstract
intentional type into concrete code.  For example, by reading the
documentation, they know how to write a C++ class for the intentional
type and add useful methods to it, or how to write a UI widget that
allows displaying and maybe high-level editing of values of that type.

The documentation should basically be a description of the set of
values that are permissible for this type (using other already defined
intentional types or the representational types from above), and what
they mean.  For example, the "calendar-time" type could say that only
"uint64" values are allowed, and that they are the number of
nano-seconds since midnight January 1, UTC.

Another example are enumerations: the documentation of
"compass-direction" can say that the value is one of the four "int32"
values 0, 90, 180, 270 where 0 means North, 90 means East, etc.

Intentional types can have names, so that you can refer to them in the
documentation of other types.  Names are optional however: if you use
a type in only one place, you can write its definition right there,
without having to give it a name.

If you intend a type to be used in many places (such as the types
defined here later on), you should give it a name, oif course.  You
can also give it parameters: when other people refer to your type,
they have to provide values for these parameters.

Every intentional type definition specifies the "base" for itself, by
referring to another intentional type.  This base can be used to make
the documentation a bit more formal.  For example, the documentation
for the "compass-direction" type would not need to explicitly say that
the numbers are "int32"s; it would just declare its base to be
"int32".

  <type name="int32">
    <doc>
      A int32 value.
    </doc>
  </type>

  <type name="int64">
    <doc>
      A int64 value.
    </doc>
  </type>

  etc.

  <type name="string">
    <doc>
      A string value.
    </doc>
  </type>

  <type name="sequence">
    <par name="min" type="int32">
    <par name="max" type="int32">
    <doc>
      A sequence of arbitrary values, with the gien minimum and maximum 
      length.
    </doc>
  </type>

  <type name="uniform-sequence">
    <par name="min" type="int32">
    <par name="max" type="int32">
    <par name="type" type="type">
    <doc>
      A sequence of values of the given type, with the given minimum and maximum 
      length.
    </doc>
  </type>

  <type name="geoloc">
    <doc>
      A sequence of two or three doubles giving a geographical location.
      The first number is latitude, the second longitude, both in degrees.
      If a third number is present, it is the altitude in meters.
    </doc>
    <base>
      <uniform-sequence min="2" max="3" type="double"/>
    </base>
  </type>

  <type name="type">
    <doc>
      A intentional type.  ...
    </doc>
  </type>
