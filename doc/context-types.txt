A high-level type system for the Free Desktops
==============================================

Or, language bindings for types.

Desktop environments are not just for starting applications anymore.
Data is flowing freely between well-integrated components, and the
easier the data flows, the better the integration of the components.

Not all components are written in the same programming language, of
course, and when letting data flow between them, it needs to be
represented in many different ways.  For example, GConf stores values
differently than they travel over D-Bus, which is different again from
how they are passed as GValues to signal handlers, which is different
from how Perl wants to store it.

The desktop environment is heading towards a cooperative, dynamic
environment, and it needs a rich and strong type system to tie its
components together.  Sending lines of text over pipes and matching
them against ad-hoc regular expressions just doesn't cut it.

In an attempt to define such a common type system, this document
collects many different systems for representing values, and unifies
them by mapping the common dynamic type system into them.

The common type system defined here is rich enough to represent any
reasonable value; it's roughly equivalent to what dynamic languages
like Perl and Python have.

But it goes one crucial step further: it allows the definition of new
abstract, intentional types.  Intentional types give additional
information about a value that is not available from the
representation alone.

For example, a integer can be used to denote a point in time by saying
that it is the number of seconds since a certain epoch.  All places
that interact with such a value need to agree on this intention.

This agreement can happen informally, via documentation or just plain
common sense.  Nothing wrong with that.  It is, however, also helpful
to formalize this so that documentation can be precise without much
extra effort, up to a level where the machine itself is able to check
whether everybody agrees on the intentional types.

The age old battle between static and dynamic types also matters here:
how much type information should be associated with the values
themselves?  The boundary is exactly between intentional and
representational types.  Intentional types are those that only the
programmer or compiler know about, representational types are those
that are only known at run-time.

In a completely statically typed language, we only have raw bytes at
run-time without any representational type information.  All parts of
the program need to agree that the intention is for those four bytes
over there to be used as a 32-bit integer.  Statically typed programs
are littered with declarations of intentional types, and language
processors use them to (more or less) check program consistency and to
select the right division instruction based on whether the four bytes
over there are intended to be a signed number or an unsigned one.

In a dynamically typed language, values carry a lot of
representational type information.  Code can easily be polymorphic and
do different things depending on whether a value is an integer or a
string.  It can also perform consistency checks at run-time, which is
more robust than doing it at compile time, but doesn't go as far since
intentional types are not available.

Dynamic languages often don't have any means to declare intentional
types for the benefit of the compiler; they only exist in the head of
the programmer who expresses them by selecting the right operation
manually.  For example, if a string is intended to be a URL, you need
to use 'utils.net.web.url.get_scheme (url)' explicitly.  If the
intentional type could have been declared in the language, it could
have selected the right function automatically from just 'url.scheme()'.

Thus, and coming back to the ground now, we define a concrete type
system here with a rich representational part and a lightweight and
flexible intentional part.

For the representational part, we define how it is implemented for a
number of existing value systems.  For the intentional part, we define
how it can be translated into a number of languages, both those with
static type declaration and those where intent is mainly expressed by
manually selecting the right operations.

Intentional types are not optional; they are generally needed to make
sense of values.  A programmer learns about them by reading
documentation; if a debugging tool needs to find out a intentional
type at run-time, there must be some way to find it.

This means that declaration languages like D-Bus introspection
facilities and GConf schemas need to be extended to support our
intentional types.  Thus, purely declarative languages like these are
also included in our list of supported languages.

[source,C]
----
/* Witty example here. */
----

We also give a list of common intentional types, of course.

This document then has three dimensions of extensibility:

- A new value system can be added by defining how the representational
  part of the common type system maps to it.

- A new language can be added by defining how intentional types are
  implemented in it, and by implementing all common intentional types.

- A new common intentional type can be added by defining it and
  implementing it in all languages.

The representational part of the common type system is not supposed to
change frequently, but adding a new intentional type should be
considered routine.

The representation part of the common type system is restricted by the
lowest common denominator of all the value system implementations that
we want to include.  We don't want to distort the existing value
systems too much, and force people to write code that feels unnatural
for them.

For example, not all value systems can directly represent complex
numbers or multiple precision integers, but any grown up type system
should include them.  We solve this conflict by relying on the
intentional types: Instead of grafting complex numbers onto every
value system, we only define a intentional type for them.

Currently supported value systems: QVariant, D-Bus messages, GValue,
GConfValue, GVariant, Python values, Perl values, JavaScript values,
GKeyFile, JSON, YAML, Nepomuk ontologies, SQL, SparQL, Common Lisp
values.

Currently supported languages: Python, Perl, JavaScript, Java, C#, C++
with QVariant, plain C++, C with D-Bus/GValue/GConfValue/GVariant,
plain C, Vala, D-Bus introspection, D-Bus IDL (didl), GConf schema,
our own XML schema.


Representational types
----------------------

Whenever there is a choice of representation in the following table,
it should be taken to mean: Represent the value with the first
alternative in the list that is possible, even if that loses
precision.

For example, a 64 bit signed integer is represented in GConf as a
"int" if it fits, and as a "double" if not.  It will always fit into a
double, but it might mean chopping off some low bits.

- null

  The null value.

  [ Not sure about this at all.  Need to review existing D-Bus
    bindings to Perl etc.]

  QVariant:   QVariant::Null
  D-Bus:      '()'
  GValue:     G_TYPE_NONE
  GConf:      empty GCONF_VALUE_LIST with type GCONF_VALUE_BOOL
  GVariant:   '()'
  Perl:       undef
  Python 2:   None
  CL:         nil

- bool

  A boolean

  QVariant:   QVariant::Bool
  D-Bus:      'b'
  GValue:     G_TYPE_BOOLEAN
  GConf:      GCONF_VALUE_BOOL
  GVariant:   'b'
  Perl:       number, 0 or 1.
  Python 2:   number, 0 or 1.
  CL:         nil or t

- int32

  Signed 32 bit integer

  QVariant:   QVariant::Int
  D-Bus:      'i'
  GValue:     G_TYPE_INT
  GConf:      GCONF_VALUE_INT
  GVariant:   'i'
  Perl:       number
  Python 2:   int
  CL:         number

- int64

  Signed 64 bit integer

  QVariant:   QVariant::LongLong
  D-Bus:      'x'
  GValue:     G_TYPE_INT64
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   'x'
  Perl:       number
  Python 2:   int or long
  CL:         number

- uint32

  Unsigned 32 bit integer

  QVariant:   QVariant::UInt
  D-Bus:      'u'
  GValue:     G_TYPE_UINT
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   'u'
  Perl:       number
  Python 2:   int or long
  CL:         number

- uint64

  Unsigned 64 bit integer

  QVariant:   QVariant::ULongLong
  D-Bus:      't'
  GValue:     G_TYPE_UINT64
  GConf:      GCONF_VALUE_INT or GCONF_VALUE_DOUBLE
  GVariant:   't'
  Perl:       number
  Python 2:   int or long
  CL:         number

- double

  Double precision floating point number

  QVariant:   QVariant::Double
  D-Bus:      'd'
  GValue:     G_TYPE_DOUBLE 
  GConf:      GCONF_VALUE_DOUBLE
  GVariant:   'd'
  Perl:       number
  Python 2:   double
  CL:         number

- string

  String of Unicode code points

  QVariant:   QVariant::QString
  D-Bus:      's'
  GValue:     G_TYPE_STRING
  GConf:      GCONF_VALUE_STRING, UTF-8.
  GVariant:   's'
  Perl:       string
  Python 2:   unicode
  CL:         string

- sequence

  Sequence of values

  QVariant:   QVariant::List
  D-Bus:      'av'
  GValue:     G_TYPE_POINTER pointing to a GSList of GValues.
              (XXX - find something better, must be somewhere.)
  GConf:      GCONF_VALUE_LIST or chained GCONF_VALUE_PAIRs
  GVariant:   'av'
  Perl:       array
  Python 2:   list
  CL:	      list

- map

  Mapping from strings to values, with no duplicated keys.

  QVariant:   QVariant::Map
  D-Bus:      'a{sv}'
  GValue:     G_TYPE_HASH_TABLE (?)
  GConf:      Chain of GCONF_VALUE_PAIRs,
              with the cars being a pair of GCONF_VALUE_STRING and an
              arbitrary value.
  GVariant:   'a{sv}'
  Perl:       hash
  Python:     dict
  CL:	      alist

A mini-DOM
----------

The representational types can be used as a mini-DOM for a small
subset of XML.  This is useful when the small subset suffices but you
still want to be enterprise ready.  Intentional type definitions use
this subset, for example, and are thus easily handled at run-time.

Converting a piece of XML produces two things: a 'tag' and a 'value'.
The tag is a string or null, and the value is either a string or a
map, according to the following rules:

  TEXT                -> tag: null, value: TEXT
  <foo>TEXT</foo>     -> tag: foo, value: TEXT
  <foo>ELT...</foo>   -> no ELT must be TEXT
                         tag: foo, value: map from the
                         tags of the ELTs to their values.
  <foo attr="TEXT">ELT...</foo>
                    -> equivalent to <foo><attr>TEXT</attr>ELT...</foo>

Examples, showing how XML maps to Python and to Common Lisp.

  <foo>bar</foo>
  => ('foo', 'bar')
  => (foo bar)

  <foo>
    <bar>Hi</bar>
  </foo>
  => ('foo', {'bar': 'Hi'})
  => (foo (bar "Hi"))

  <foo bar="Hi"/>
  => ('foo', {'bar': 'Hi'})   (Same thing)
  => (foo (bar "Hi"))

  <contact online="true">
    <name>
      <first>Foo</foo>
      <last>Bar</last>
    </name>
  </contact>
  => ('contact', {'online': 'true',
     		  'name': {'first': 'Foo',
                           'last': 'Bar'}})
  => (contact (online "true")
              (name (first "Foo")
	            (last "Bar")))

  <cat>
    dog
    <ernie>bert</ernie>
  </cat>
  => ERROR: dog has no tag.


Intentional types
-----------------

The most important part of a intentional type definition is its
documentation.  The documentation is the thing that explains the
intent to programmers, so that they can 'reify' the abstract
intentional type into concrete code.  For example, by reading the
documentation, they know how to write a C++ class for the intentional
type and add useful methods to it, or how to write a UI widget that
allows displaying and maybe high-level editing of values of that type.

The documentation should basically be a description of the set of
values that are permissible for this type (by referring to other
already defined intentional types or the representational types from
above), and what they mean.  For example, the "calendar-time" type
could say that only "uint64" values are allowed, and that they are the
number of nano-seconds since midnight January 1, UTC.

Another example are enumerations: the documentation of
"compass-direction" can say that the value is one of the four "int32"
values 0, 90, 180, 270 where 0 means North, 90 means East, etc.

Intentional types can have names, so that you can refer to them in the
documentation of other types.  Names are optional however: if you use
a type in only one place, you can write its definition right there,
without having to give it a name.

If you intend a type to be used in many places (such as the types
defined here later on), you should give it a name, of course.

When other people refer to your type, they can provide a set of
parameters to specialize it.  You should document which parameters are
meaningful and what they do, of course.  You should also formally
declare which paramaters are valid.  [ XXX - explain 'rest' parameter
and how they are passed on to the base type. ]

Every intentional type definition specifies the "base" for itself, by
referring to another intentional type.  This base can be used to make
the documentation a bit more formal.  For example, the documentation
for the "compass-direction" type would not need to explicitly say that
the numbers are "int32"s; it would just declare its base to be
"int32".

This simple form of inheritance allows one to write generic code for a
base type


In a context where a type is expected:

  NAME                       - refers to type named NAME
  <NAME>PARM...</NAME>       - refers to type named NAME, specialized
                               with PARM...
  <typedef>ELT...</typedef>  - anonymous type with inline definition

Attributes for type definitions:

  name  - the name (string)
  parms - valid paramaters (map from parm name to map of ...)
  doc   - documentation (either string, or a map language code -> string)
  base  - the base type (type)
  
Fundamental types:

  <typedef name="int32">
    <doc>
      A int32 value.
    </doc>
  </typedef>

  <typedef name="int64">
    <doc>
      A int64 value.
    </doc>
  </typedef>

  etc.

  <typedef name="string">
    <doc>
      A string value.
    </doc>
  </typedef>

  <typedef name="sequence">
    <params>
      <min doc="Minimum length"/>
      <max doc="Maximum length"/>
    <params>
    <doc>
      A sequence of arbitrary values, with the minimum and maximum 
      length given by the "min" and "max" parameters, respectively.
    </doc>
  </typedef>

  <typedef name="map">
    <params>
      <keys doc="Allowed keys"/>
    </params>
    <doc>
      A map.  If given, the "keys" parameter determines which keys are
      allowed.  The "keys" parameter should be a map itself, from key
      names to a map with the attributes of the key.  Attributes of a
      key are "doc" and "type".
    </doc>
  </typedef>

Useful generic types

  <typedef name="value">
    <doc>
      Any representable value.
    </doc>
  </typedef>

  <typedef name="number">
    <doc>
      A number, represented as either a "int32", "uint32", "int64", "uint64", or "double".
    </doc>
  </typedef>

  <typedef name="integer">
    <params>
      <min doc="Lower bound"/>
      <max doc="Upper bound"/>
    </params>
    <doc>
      A integer, represented as any of the numeric types.  If the value 
      is a "double", it is rounded to an integer, but necessarily to
      the nearest.  The "min" and "max" parameters, when given, constrain 
      the range of the integer.
    </doc>
  </typedef>

  <typedef name="uniform-sequence">
    <params>
      <min doc="Minimum length"/>
      <max doc="Maximum length"/>
      <type doc="Type of the elements"/>
    </params>
    <doc>
      A sequence of values of the given type, with the 
      minimum and maximum length given by the "min" and "max" parameters.
      The type of all elements is given by the "type" parameter.
    </doc>
    <base>sequence</base>
  </typedef>

  <typedef name="string-enum">
    <parms>
      <rest doc="The possible values">
    </parms>
    <doc>
      This is the base type for enumerations of fixed strings.  The
      parameters describe the possible values.  Each parameter is a
      map from the string to a map with might have a "doc" entry.
    </doc>
  </typedef>

  <typedef name="int-enum">
    <parms>
      <rest doc="The possible values">
    </parms>
    <doc>
      This is the base type for enumerations of fixed integers.  The
      parameters describe the possible values.  Each parameter is a
      map from a symbol string to a map with a "val" entry.
    </doc>
  </typedef>

Specific types

  <typedef name="geoloc">
    <doc>
      A sequence of two or three doubles giving a geographical location.
      The first number is latitude, the second longitude, both in degrees.
      If a third number is present, it is the altitude in meters.
    </doc>
    <base>
      <uniform-sequence min="2" max="3" type="double"/>
    </base>
  </typedef>

  <typedef name="temperature"
        base="double"
	doc="A temperature in Kelvin."/>

  <typedef name="screen-edge">
    <doc>
      Indicates an edge of a rectangular screen, relative to
      the natural orientation of the video hardware driving it.
      It can be one of the four strings "top", "left", "right",
      and "bottom".
    </doc>
    <base>
      <string-enum>
	<top/> <left/> <right/> <bottom/>
      </string-enum>
    </base>
  </typedef>

  <typedef name="screen-edge-ints">
    <doc>
      Indicates an edge of a rectangular screen, relative to
      the natural orientation of the video hardware driving it.
      It can be one of the four values "top", "left", "right",
      and "bottom", encoded as an integer.
    </doc>
    <base>
      <int-enum>
	<top val="0"/> <left val="1"/> <right val="2"/> <bottom val="3"/>
      </string-enum>
    </base>
  </typedef>

  <typedef name="energy" base="double">
    <doc>
      An amount of energy, in Watt-hours.
    </doc>
  </typedef>

  <typedef name="time" base="int64">
    <doc>
      A point in time, represented as the number of nano-seconds since
      00:00 January 1, 1970, UTC.
    </doc>
  </typedef>

  <typedef name="duration" base="int64">
    <doc>
      A time duration, in nano-seconds.
    </doc>
  </typedef>

  <typedef name="percentage" base="int32">
    <doc>
      A percentage.
    </doc>
  </typedef>


Intentional types and context properties
----------------------------------------

  <key name="TopEdge" type="screen-edge">
    <doc>
      Blah blah.
    </doc>
  </key>

  <key name="TopEdge">
    <type>
      <string-enum>
	<top/> <left/> <right/> <bottom/>
      </string-enum>
    </type>    
    <doc>
      Blah blah.
    </doc>
  </key>

  <key name="TopEdge">
    <type>
      <typedef>
        <doc/>
        <base/>
      </typedef>
    </type>    
    <doc>
      Blah blah.
    </doc>
  </key>


Intentional types and static languages
--------------------------------------

The normal use of intentional types is as follows: while programming
in language X, you read some API documentation and find out that some
argument to a function is of type "geoloc"; you then go to the
documentation of "geoloc" and read how a "geoloc" works in language X.

For C++ with QVariants, say, a geoloc could simply remain a list of
two or three doubles, or it could be a QVariant::RectF with the height
being abused as the altitude, or a new QMetaType could be invented.

For plain C++, a geoloc might be reified as a class in some library
that you need to link against.

In other words, we need C++ language bindings for the intentional
types.  These language bindings are maintained together with the
intentional types.  [ Not much is known yet how this would work. Lots
of automation should be possible by using type inheritance, but the
point is to create something that is natural and nice for the target
language, and that can't be fully automated. ]

At the language boundaries, such as when marshalling and unmarshalling
values for a D-Bus message, a geoloc value needs to be converted to
and from a list of doubles.  This conversion code is also maintained
together with the language bindings.  In any case, the types are well
enough documented that the necessary code can be written manually if
needed.


C with GVariant
~~~~~~~~~~~~~~~

- geoloc

  typedef struct {
    double latitude;
    double longitude;
    double altitude; // -1 if unknown.
  } DGeoLoc;

Rest is done with inheritance:

- duration

  typedef int64_t DDuration;

- screen-edge

  typedef char *DScreenEdge;

- screen-edge-ints

  typedef int DScreenEdgeInts;
  #define D_SCREEN_EDGE_TOP    0
  #define D_SCREEN_EDGE_LEFT   1
  #define D_SCREEN_EDGE_RIGHT  2
  #define D_SCREEN_EDGE_BOTTOM 3

- percentage

  typedef int DPercentage;

These definitions are in libdesktoptypes, built from the desktop-types
source package, which includes everything else as well, such as this
document, bindings for C++ with QVariant, etc.

There is also libdesktoptypes-glib with g_variant_from_geoloc, etc,

Then, libcontextprovider has context_provider_set_geoloc,
context_provider_set_duration, etc, probably as macros using
g_variant_from_geoloc.  Maybe we can have support for doing this
automatically.

C++ with QVariant
~~~~~~~~~~~~~~~~~

Types should be compatible with C and have the same names.

- geoloc

  struct DGeoLoc {
    double latitude;
    double longitude;
    double altitude; // -1 if unknown.

    DGeoLoc();
    DGeoLoc(double, double);
    DGeoLoc(double, double, double);

    DGeoLoc (QVariant);
    operator QVariant ();
  };

  Registered as "DGeoLoc" with QMetaType.

- rest identical with C.

This is in libdesktoptypes-qt, built from the same desktop-types as
the C bindings.
