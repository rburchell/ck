How to hack on the ContextKit
=============================

These are the coding and release guidelines for the ContextKit.  They
are quite general, so if you like them, feel free to copy them into
your project.

Build system
------------

We use the autotools in their 'foreign' strictness plus pkg-config.
We don't use qmake, even for Qt programs or libraries.  Use pkg-config
when you use Qt libraries and write explicit rules for invocations of
tools like moc.  See the ContextCommander for an elaborate example.
[Soon]

Upstream and Packaging
----------------------

We separate 'upstream' code development on the one side and packaging
for Maemo on the other.  Both happen on branches: a branch for
upstream development is called "upstream branch" and doesn't have a
debian/ directory in it; a branch with a debian/ directory is called a
"packaging branch".

A upstream branch is merged into a packaging branch at controlled
points in time.  (See below "Making a release" for more details.)
Never merge a packagin branch into upstream branch.  If you want to
move changes from a packaging branch to a upstream branch, cherry-pick
them.

Feel free to make smallish changes to to the actual source or
Makefiles in a packaging branch, but always with the intention of
moving them to upstream in the immediate future.  Thus, you should
isolate these changes into their own commits: never make a commit that
includes changes to both files inside and outside of debian/.

As explained below, only merge release tags into a packaging branch.
If you need a fix from the upstream branch that is not in any release
yet, cherry pick it to the packaging branch.

The "master" branch is our main upstream branch, and "pkg-master" is
the packaging branch that follows "master".

Documentation
-------------

Documentation is in HTML and generally distributed in the tarballs and
distribution tags.  We do this so that recipients don't need all the
crazy build tools that we use and still get some documentation.

Thus, all documentation files should be added to EXTRA_DIST and
MAINTAINERCLEANFILES.

Since timestamps are not always preserved well enough when checking a
distribution tag out of Git, it might happen that documentation is
being regenerated also during a pure target build, and might fail.

It's not yet totally clear how to cope with that: one approach is to
have something like autotool's "missing", another might be to touch
all 'interesting' files just before building.  Let's see.

Environments
------------

Our code should be as portable as possible, but a few environments are
more important than others.

There are supported development environments, and compilation
environments.

 - Development

 For fun and fame, our code should work in a typical Debian unstable
 and Ubuntu environment, augmented with our own packages that we build
 from source.  (If it works in Fedora, too, cool!)  This is our
 day-to-day development environment.

 The projects only need to work fully when installed.  Thus, the
 projects must be cleanly installable in arbitrary prefixes.  The
 following should work to install everything in $HOME/install:

   ./configure --prefix $HOME/install/
   make install

 The installed projects should then fully work with these settings:

   PATH=$HOME/install/bin/
   LD_LIBRARY_PATH=$HOME/install/lib/
   PKG_CONFIG_PATH=$HOME/install/lib/pkgconfig/

 The "master" branches on the mainline repos on PMO should always pass
 "make check" in the development environments, after doing the
 necessary autogen.sh gymnastics in a fresh checkout.

 For projects that can not be developed in Debian or Ubunute, do
 whatever needs to be done.  Document this in a "HACKING" file in the
 top directory of the source tree.

 However, try to port the project to Debian/Ubuntu instead, maybe by
 making certain features optional or by importing the missing dependencies.

 - Compilation

 For pain and profit, the code also needs to compile in a Harmattan
 target in Scratchbox.  We only use Scratchbox 1 for now, with the
 following devkits: perl, debian-etch, doctools.

 When in doubt, follow these instructions to set it up:

    https://projects.maemo.org/trac/sdk/wiki/Harmattan

 Distribution tags (see below) should be buildable with one of these
 two commands right after checking them out

   ./configure && make     (for a upstream source tree)
   dpkg-buildpackage       (for Debianized sources)

 Note that things like running ./autogen.sh or more generally
 regenerating files that are contained in distribution tags is not
 supported in the compilation environment.

Coding style
------------

We follow the DUI coding style for C++ code.  In brief:

 - Linux style, but
 - Indentation offset is 4 and
 - Maximum line length is 120.

For Python:

 - PEP 8, but
 - Maximum line length is 120.

For Vala:

 - Linux style with indentation offset 8, but
 - Maximum line length is 120.

Generated files
---------------

No generated file should be committed to a branch.  After checking out
(or exporting) a branch, running "./autogen.sh" will get the tree into
a shape where "./configure && make" or "dpkg-buildpackage" will work.

Distribution tags are different, see below.

ChangeLogs
----------

There is no GNU-style ChangeLog.  We assume that the VCS keeps a
detailed log of the changes.  Likewise, debian/changelog does not
record detailed changes, just the stuff that would go into an
announcement.

Upstream branches have a NEWS file that records user-visible changes.

Marking fixed bugs
------------------

When committing a change that is supposed to fix a bug, make a
annotated tag for it with the name "fixes_NNNNN" where NNNNN is the
Bugzilla bug number.  Use the message "Fixes: NB#NNNNN - SUMMARY"
where SUMMARY is of course the one-line summary of the bug.

(The annotation message is there to carry the summary.  Bugzilla is
not visible to the outside, and we should give some hints about what
kind of bugs we have fixed.  With a public Bugzilla, a simple
leightweight tag would suffice.)

Making a distribution tag
-------------------------

No generated file should be committed to a branch, but distribution
tags should be buildable with "./configure && make" or
"dpkg-buildpackage" right away after exporting them, without the need
to run autogen.sh.  The created Debian source package should be clean,
and not contain any files that are not supposed to be distributed.

In general, a tag should contain exactly the files that would be in a
distribution tarball produced by "make dist".  In essence, we use tags
in a VCS repository instead of the traditional tarballs.

Note that distribution tags are usually created in the development
environment, outside of Scratchbox.

Here is the general procedure:

- Clean everything that can be generated.

  $ make maintainer-clean || make distclean

- Recreate the build cruft.

  $ ./autogen.sh

- Configure your source tree as needed for making a release.

  $ ./configure --enable-maintainer-mode --enable-gtk-doc

- Build the source tree and do a "make distcheck"

  $ make
  $ make distcheck

- Make the distribution tag with git-make-dist (in the tools/ directory).

  $ git-make-dist TAG

The "git-make-dist" script runs "make distdir" and creates a tag with
the contents of the created directory.

Making releases
---------------

Version numbers are bumped post-release and have a "~unreleased"
suffix.  Thus, configure.ac always contains the version that is going
to be released next (with a "~unreleased" suffix) and debian/changelog
contains a prepared entry for the next release (with a "~unreleased"
suffix).

That suffix is there to make it clear that we are using the
"post-release bump" schema.  It also reduces confusion when you create
a tarball or Debian package from a branch for testing purposes.  Those
tarballs and packages will be clearly marked to be 'unreleased', and
can not be confused with the real releases.  Do not distribute these
unreleased packages to other people.

If you do want to label multiple intermediate non-releases, use
suffixes of the form "~unreleasedN".  Do this by changing the existing
debian/changelog entry in place.  Do not create a new entry.

As a rule, configure.ac in a upstream branch should always have a
version number with a "~unreleased" suffix.  The distribution tags made
from a branch should never have a version number with a "~unreleased"
suffix.

Likewise, the topmost entry of the debian/changelog in a branch should
always have a "~unreleased" suffix, and no other entry should have
such a suffix.  A debian/changelog file in a distribution tag should not
have a ~unreleased suffix.

Also, the configure.ac file in a packaging branch should _not_ have a
"~unreleased" suffix.  In other words, only merge the
"release_VERSION" tags into a packaging branch.  Never merge the
upstream branch itself between releases.

If you want to merge the upstream branch with the packaging branch for
experimenting, make a new branch for this purpose.  The continous
integration machinery creates such a throw-away branch whenever
"master" changes, with the name "pkg-next".

** Upstream releases

When making the release in a upstream branch (a branch without the
packaging bits), remove the "~unreleased" suffix in configure.ac.  You
can also increase the version more generally at this time, such as
from 0.1.5~unreleased to 0.2.0.

Then do all the steps listed in "Making a distribution tag" *except*
running git-make-dist.  Once the final "make distcheck" succeeds,
commit the removal of the "~unreleased" suffix with the commit message
"Released VERSION."  (VERSION is of course the version in configure.ac
without the ~unreleased suffix.)

Then make a annotated tag with the name "release_VERSION" and the
message "Released VERSION."

Then run all the steps in "Making a distribution tag" again, this time
*including* git-make-dist.  Use the plain VERSION as the tag name.

Then bump the version in configure.ac by increasing the least
significant component and add the "~unreleased" suffix again.  Commit
this with the message "Prepare VERSION" where VERSION is the new
version without the "~unreleased" suffix.

Push everything.  Don't forget to push the tags as well.  If you can't
push at this time because you need to pull first, do that but be
careful to merge the remote changes.  Do not use "git pull --rebase"
at this time.

** Merging a upstream release into a packaging branch.

Merge the most recent "release_VERSION" tag into the packaging branch.
Update the topmost debian/changelog entry (which has the ~unreleased
suffix) to have version VERSION-1~unreleased, adding the text "New
upstream release.".  Add a summary of the changes compared to the last
upstream release based on the NEWS file in the upstream release.

Look for tags of the form "fixes_NNNNN" and copy their messages into
debian/changelog.  [ This should be automated. ]

** Package releases

Making a release on a packaging branch is very similar to releasing a
upstream branch.

The only differences are:

 - You leave configure.ac alone, which shouldn't have any ~unreleased
   suffix if you have followed the rule about only merging
   release_VERSION tags into a packaging branch.  Instead, you remove
   the ~unreleased suffix in debian/changelog.

   VERY IMPORTANT: Update the date in the topmost debian/changelog
   entry whenever you change it.

 - Instead of using "release_VERSION" for the tag, you use
   "pkg_VERSION-REVISION".

 - You use "VERSION-REVISION" for the distribution tag name.
   Git-make-dist will automatically include the debian/ directory in
   the distribution tag.

 - When bumping the version post-release, you create a new, empty
   entry in debian/changelog.  Make sure it has a valid signature line
   so that packages can be build with it.

Snapshots versus releases
-------------------------

We make a 'real' release as explained above whenever we need to
integrate something.  Such a release gets a real version number, and
not a timestamp suffix or similar.
